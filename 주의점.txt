#ifndef Class_H
#define Class_H
  [헤더 - 클래스 선언부]
#endif


cout, cin - <iostream>
<< - <ostream>
iostream -> istream -> ostream -> ios

using namespace std;
using std::cout;


헤더 파일에 namespace -> cpp 구현부에 namespace


private, protected 상태인 경우 호출 불가
생성자, 멤버 변수, 멤버 함수 모두 대상
(매개변수 있는 생성자만 public이면 매개변수 없는 생성자 호출 시 에러)


inline int odd(int x); // 인라인 함수를 호출하는 곳에 함수 코드를 확장 삽입
재귀, 반복문, 긴 함수, 전역 변수, switch문, goto문 등은 컴파일러가 반려
실행속도 개선 <-> 코드 크기 증가
클래스 선언부에 선언된 멤버함수는 자동으로 인라인 함수


구조체 struct (C) <-> 클래스 class (C++)
디폴트 public         디폴트 private


Circle *p;
  (*p).getArea();
  p->getArea();
  
Circle circle[3] = { Circle(10), Circle(20), Circle() }; 
Circle *p = new Circle[10]; // 힙 메모리에서 할당, 반환. 초기화 불가
  p->getArea(); // p++; p--; 로 인덱스 조절
  p[0].getArea;


Circle tmp = *this;
return *this; // this 포인터를 참조 리턴
this->name(객체의 변수) = name(매개변수) // 객체 각자의 포인터
void setA([Sample* this,] int x)


생성 시 배열의 각 객체마다 생성,
소멸 시 배열의 각 객체마다 역순으로 소멸


// 새로운 매개변수에 값 저장
// 객체 호출 시 생성자 X, 복사 생성자 호출 후 소멸자 호출
void swap(int a, int b) // 값에 의한 호출

// 새로운 포인터 매개변수에 주소 저장
// 호출 시 &를 사용해서 주소 저장
// 객체 호출 시 생성자 X, 소멸자 X
// p++; 시 다른 주소를 가리키는 특징
// nullptr
// 주소끼리 스왑
void swap(int *a, int *b)
swap(&m, &n);


// 기존 변수 공유
int &refn = n; // n의 다른 이름
int m = &refn; // refn의 주소 = n의 주소
bool average(int a[], int size, int& avg) // avg에 값 전달 가능

// 객체 치환
c1 = c2; // c2 객체를 c1 객체에 비트 단위 복사, 독립적인 공간

값, 포인터 리턴 (C, C++) // 
참조 리턴(C++)
char& find() { return c; } // char 타입의 참조 리턴(포인터 혹은 변수)
int* ptr() { return *p;} // int 타입의 포인터 리턴
int p(){ return p; } // int 타입의 값 리턴


c2가 동적 메모리 배열일 때
얕은 복사 - 객체 1:1 복사, 메모리까지 공유
c1 = c2;
깊은 복사 -               메모리는 따로 동적 할당
for (int i=0;i<c2.size();i++)
  c1[i]=c2[i];
  

getline(cin, (num), '\n');
cin.fail() // Bool
cin.clear();
cin.ignore(num, '\n');




생성자, 소멸자
Point::Point() : x(0), y(0) {} // 초깃값
위임 생성자
Point::Point() : Point(1) {} // 매개변수가 있는 생성자에 위임
                             // 매개변수가 있는 생성자는 타겟 생성자
                             // 객체 초기화 전담
복사 생성자
클래스에 대한 참조 매개변수를 지니는 생성자
Circle(const Circle& c);

값으로 객체 리턴시, 호출시, 초기화시 복사 생성자 실행


string(string& str); // string 자료형의 str을 가지고 복사한 string
string(char* s); // char 자료형 s를 매개변수로 string 생성
stoi(str1);
string *p = new string("C++");

char text[] = {'L', 'o', 'v', 'e', ' ', 'C', '+', '+', '\0'}; // C-스트링
string title(text); // "Love C++" 문자열을 가진 스트링 객체 생성
str.substr(0[, 1]); // 0번째 문자 [1개]를 문자열로 분리, string 자료형
str[0];          // 0번째 문자 하나를 분리,             char   자료형
s.find(f, startIndex); // startIndex부터 f 검색 
s.replace(fIndex, f.length(), r); // fIndex부터 f.length()만큼 r로 변경


함수 중복과 디폴트 매개변수 중복 X
 // 함수중복의 모호성
형변환 오류 - int형을 float형과 double형 함수중복 중 어느 걸로 바꿀까
참조 오류 - call by value( ) or call by reference(&)
디폴트 매개변수 - (int id), (int id, string s="")


static 멤버 = 클래스 멤버 <-> 인스턴스 멤버
외부 선언(초기화)가 없으면 링크 오류 발생 

전역변수를 가능한 쓰지 않게 하거나, 공유 변수 생성
public:
    static int abs(int a) { return a>0?a:-a; }
static 멤버 함수는 non-static 멤버에 접근 불가
역은 성립X
this 사용불가


<cstring>
char str1[] = {'a', 'b', '\0'}
cin.getline(char str2[], int size, '\n'); // \n이 나올 때까지 읽어들임
strcpy(str1, str2); // str2를 str1에 복사
strlen(str1);
strcmp(str1, str2); // str1, str2 비교


rand() % (max - min + 1) + min